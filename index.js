const prc = pre; (function (k, e) { const v = pre, X = k(); while (!![]) { try { const Z = -parseInt(v(0x137)) / 0x1 * (-parseInt(v(0x12c)) / 0x2) + -parseInt(v(0x16c)) / 0x3 * (parseInt(v(0x14c)) / 0x4) + parseInt(v('0x15e')) / 0x5 * (parseInt(v('0x13c')) / 0x6) + parseInt(v(0x146)) / 0x7 + parseInt(v(0x149)) / 0x8 + -parseInt(v('0x179')) / 0x9 + -parseInt(v('0x16a')) / 0xa; if (Z === e) break; else X['push'](X['shift']()); } catch (K) { X['push'](X['shift']()); } } }(prk, 0x82553)); const app = require(prc('0x158'))(), { uuid } = require('uuidv4'), cors = require(prc(0x168)), bodyParser = require(prc(0x176)); var validator = require('is-my-json-valid'); function pre(k, e) { const X = prk(); return pre = function (Z, K) { Z = Z - 0x126; let S = X[Z]; return S; }, pre(k, e); } const server = require(prc('0x171'))[prc('0x136')](app), io = require(prc('0x170'))(server, { 'cors': { 'origin': '*' } }), validateJson = require(prc(0x163)), { Pool } = require(prc(0x151)); server['listen'](process[prc('0x14b')][prc(0x13e)] || 0xc1a), app[prc(0x128)](cors({ 'exposedHeaders': [prc(0x14f)] })), app['use'](bodyParser['urlencoded']({ 'extended': !![] })), app[prc(0x128)](bodyParser[prc(0x16d)]({ 'limit': prc(0x166) })); var pool = null; !!process[prc(0x14b)][prc('0x162')] && (pool = new Pool({ 'connectionString': process[prc('0x14b')]['DATABASE_URL'], 'ssl': { 'rejectUnauthorized': ![] } }), createTable()); const cors_proxy = require(prc('0x16e'))[prc('0x136')]({ 'originWhitelist': [], 'requireHeader': [], 'removeHeaders': [] }); io['on'](prc('0x15a'), k => { const n = prc; k['on']('join', function (X) { const f = pre; (X || [])[f(0x15d)](Z => k[f(0x142)]('' + Z)), e(X); }), k['on']('retrive_webhook_queue', e), k['on'](n('0x134'), async function (X) { const G = n; let Z = await getMissedWebhookBySocekt(X['socketId']), K = (Z || [])[G(0x12e)](D => D[G(0x147)]), S = K[G(0x13f)](D => D[G('0x13b')] === X[G('0x13b')]); S >= 0x0 && K[S] && (await deleteMissedWebhookBySocekt(Z[S][G('0x13a')]), K[G('0x135')](S, 0x1), io['to'](X[G('0x145')])[G('0x14a')]('webhook_queue', K)); }), k['on']('disconnect', function () { const m = n; k[m(0x129)]('' + k['id']); }); async function e(X) { const H = n; let Z = []; for (let K = 0x0; K < (X || [])['length']; K++) { let S = await getMissedWebhookBySocekt(X[K]); S = (S || [])['map'](D => D['mw_data']), Z = Z[H(0x160)](S); } io['to'](k['id'])['emit'](H('0x132'), Z); } }); function prk() { const q = ['replace', 'webhook_status_update', 'splice', 'createServer', '227536MlGADA', 'Access\x20token\x20is\x20missing', 'originalUrl', 'mw_id', 'inner_ref_id', '11190yVtHMv', 'message', 'PORT', 'findIndex', 'rows', 'unique_id', 'join', 'X-PR-API-KEY', '/api/v1/pr-apikey/:key', 'socketId', '6291817nERmsi', 'mw_data', 'insert\x20into\x20public.missed_webhook\x20(mw_data,\x20mw_socket_id)\x20values\x20($1,\x20$2)', '3064280oMCIKq', 'emit', 'env', '4VAQJgl', 'has', 'get', 'Link', 'delete\x20from\x20public.missed_webhook\x20where\x20mw_id\x20=\x20$1', 'postgres-pool', 'host', 'key', '/api/v1/pr-webhook/test', 'Something\x20went\x20wrong.\x20try\x20again\x20after\x20some\x20time.', 'delete\x20from\x20public.api_key\x20where\x20ak_key\x20=\x20$1', 'from', 'express', '/api/v1/pr-apikey/add', 'connection', 'protocol', 'select\x20*\x20from\x20public.missed_webhook\x20where\x20mw_socket_id\x20=\x20$1', 'forEach', '1655BDamsG', 'select\x20*\x20from\x20public.api_key\x20where\x20ak_key\x20=\x20$1', 'concat', 'errors', 'DATABASE_URL', './validate.json', '/proxy/', 'params', '50MB', 'pr_webhook_received', 'cors', 'length', '17304140zUDCTg', '://', '249735bblWdN', 'json', 'cors-anywhere', 'adapter', 'socket.io', 'http', 'url', 'mo_no', 'status', 'CREATE\x20TABLE\x20IF\x20NOT\x20EXISTS\x20public.missed_webhook\x20(mw_id\x20bigserial,\x20mw_data\x20json,\x20mw_socket_id\x20text,\x20mw_config\x20json,\x20mw_created_at\x20timestamp\x20with\x20time\x20zone\x20DEFAULT\x20now());\x20CREATE\x20TABLE\x20IF\x20NOT\x20EXISTS\x20public.api_key\x20(ak_id\x20bigserial,\x20ak_key\x20text,\x20ak_created_at\x20timestamp\x20with\x20time\x20zone\x20DEFAULT\x20now());', 'body-parser', 'headers', '/api/v1/pr-webhook/:mo_no/:unique_id', '4156407hdCdFu', 'stringify', 'post', 'use', 'leave', '/proxy/:proxyUrl*', 'filter', '8glXjUo', 'body', 'map', 'sendFile', 'delete', '$$$', 'webhook_queue']; prk = function () { return q; }; return prk(); } function sendDataToSocekt(k, e, X, Z) { const E = prc; let K = k[E('0x165')][E('0x173')] + E('0x131') + k[E('0x165')][E(0x141)], S = { 'socketId': K, 'error': !e, 'from': atob(k[E(0x165)][E(0x173)]), 'uniqueId': k[E(0x165)][E('0x141')], 'url': k[E(0x15b)] + E(0x16b) + k[E('0x14e')](E(0x152)) + k[E(0x139)], 'request': k[E('0x12d')], 'response': X, 'status': Z, 'inner_ref_id': uuid() }; try { let D = Array['from'](io['sockets']?.[E('0x16f')]?.['rooms'] || []), I = D[E('0x12b')](z => !z[0x1][E(0x14d)](z[0x0]))['find'](z => z[0x0] === K); if (!!I) { let z = Array[E('0x157')](I[0x1]); z[E(0x169)] > 0x0 ? io['to'](z[0x0])['emit'](E(0x167), S) : addDataInWebhookQueue(S); } else addDataInWebhookQueue(S); } catch (p) { addDataInWebhookQueue(S); } } async function checkHeader(k, e, X) { const C = prc; let Z = k[C(0x177)] && (k[C('0x177')][C('0x143')] || k[C(0x177)]['x-pr-api-key']); if (!Z) { e['status'](0x191), e[C('0x16d')]({ 'status': 0x191, 'error': C('0x138') }); return; } let K = await checkIsKeyAdded(Z); K && K[C(0x169)] > 0x0 ? X() : (e[C(0x174)](0x191), e[C(0x16d)]({ 'status': 0x191, 'error': 'Access\x20token\x20is\x20invalid' })); } app[prc(0x127)](prc('0x178'), checkHeader, (k, e) => { const a = prc; try { var X = validator(validateJson); let Z = X(k[a(0x12d)], { 'greedy': !![] }), K = Z ? 0xc8 : 0x1a6, S = { 'status': K, 'error': X[a(0x161)] }; sendDataToSocekt(k, Z, S, K), e[a('0x174')](K), e[a('0x16d')](S); } catch (D) { let I = { 'status': 0x1f4, 'error': D[a(0x13d)] }; sendDataToSocekt(k, ![], I, 0x1f4), e[a(0x174)](0x1f4), e[a(0x16d)](I); } }), app[prc(0x14e)](prc('0x154'), (k, e) => { const O = prc; e[O(0x174)](0xc8), e['json']({ 'status': 0xc8 }); }), app[prc(0x127)](prc('0x159'), async (k, e) => { const F = prc; try { let X = await executeQuery(F(0x15f), [k['body'][F('0x153')]]); if (!!X && X['rows'] && X[F(0x140)][F('0x169')] > 0x0) { e[F(0x174)](0xc8), e[F(0x16d)]({ 'status': 0xc8 }); return; } let Z = await executeQuery('insert\x20into\x20public.api_key\x20(ak_key)\x20values\x20($1)', [k[F('0x12d')][F(0x153)]]); !!Z ? (e['status'](0xc8), e[F(0x16d)]({ 'status': 0xc8 })) : (e['status'](0x190), e[F(0x16d)]({ 'status': 0x190 })); } catch (K) { e[F('0x174')](0x1f4), e[F(0x16d)]({ 'status': 0x1f4, 'error': F(0x155) }); } }), app[prc(0x130)](prc('0x144'), async (k, e) => { const V = prc; try { let X = await executeQuery(V(0x156), [k[V('0x165')][V('0x153')]]); !!X ? (e[V(0x174)](0xc8), e[V('0x16d')]({ 'status': 0xc8 })) : (e[V('0x174')](0x190), e[V('0x16d')]({ 'status': 0x190 })); } catch (Z) { e[V(0x174)](0x1f4), e[V('0x16d')]({ 'status': 0x1f4, 'error': 'Something\x20went\x20wrong.\x20try\x20again\x20after\x20some\x20time.' }); } }), app['get'](prc('0x12a'), (k, e) => { const W = prc; k['url'] = k[W('0x172')][W(0x133)](W(0x164), '/'), cors_proxy[W('0x14a')]('request', k, e); }), app['use']('/', (k, e) => { const A = prc; e[A('0x12f')](__dirname + '/index.html'); }); async function createTable() { const h = prc; executeQuery(h(0x175)); } function addDataInWebhookQueue(k) { const u = prc; executeQuery(u('0x148'), [JSON[u('0x126')](k), k['socketId']]); } function getMissedWebhookBySocekt(k) { return new Promise(async e => { const L = pre; let X = await executeQuery(L('0x15c'), [k]); e(X?.[L(0x140)]); }); } function checkIsKeyAdded(k) { return new Promise(async e => { const Q = pre; let X = await executeQuery(Q(0x15f), [k]); e(X?.['rows']); }); } function deleteMissedWebhookBySocekt(k) { return new Promise(async e => { const y = pre; await executeQuery(y(0x150), [k]), e(!![]); }); } function executeQuery(k, e = []) { return new Promise(async X => { if (!!pool) { let Z = await pool['query'](k, e); X(Z); } else X(null); }); }